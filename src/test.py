import sys
import os
import filecmp
from antlr4 import *
from antlr4.InputStream import InputStream
from MIPSVisitor import MIPSVisitor
from grammars.C.CLexer import CLexer
from grammars.C.CParser import CParser
from ASTListener import ASTListener
from ASTVisitor import ASTVisitor
from SemanticalErrorVisitor import SemanticalErrorVisitor
from OptimisationVisitor import OptimisationVisitor
from LLVMVisitor import LLVMVisitor

# Path to benchmarks
PATH = "./src/tests/benchmarks/CorrectCode/"
# Write results of test to file
OUTPUT = open("results.txt", "w+")
variables = ""
# Grab each c file in benchmarks path
for file in os.listdir(PATH):
    if file.endswith(".c"):
        file = file.replace(".c", "")
        variables += file + " "
id = input("1) Run all files (LLVM)\n2) Run specific file (LLVM)\n3) Run all files (MIPS)\n4) Run specific file (MIPS)\n")
filenames = ""
# If input is 1, run all c files in benchmark path
if id == "1" or id == "3":
    filenames = variables
    print(filenames)
# If input is 2, run all given c files
elif id == "2" or id == "4":
    filenames = input("Please enter test file(s): ")
filenames = filenames.split()
filenames.sort()
print(filenames)

# For each c file given
for filename in filenames:
    file_path = PATH + filename

    f1 = open(f"{file_path}.c")
    line = f1.read()
    f1.close()

    # Generate the CST
    input_stream = InputStream(line)
    lexer = CLexer(input_stream)
    token_stream = CommonTokenStream(lexer)
    parser = CParser(token_stream)
    tree = parser.prog()

    lisp_tree_str = tree.toStringTree(recog=parser)
    # print(lisp_tree_str)

    try:
        # Generate the AST
        listener = ASTListener()
        walker = ParseTreeWalker()
        walker.walk(listener, tree)
        AST = listener.curr_node
        # Create DOT file of AST
        AST.to_dot("AST")

        # Optimise AST
        visitor_opt = OptimisationVisitor()
        visitor_opt.visit(AST)

        # Create DOT file of optimised AST
        AST.to_dot("AST_OPT")

        # Check AST for semantical errors
        visitor_err = SemanticalErrorVisitor()
        visitor_err.visit(AST)

        # Generate LLVM code from AST
        visitor_llvm = LLVMVisitor()
        visitor_llvm.visit(AST)
        # Write generated LLVM to <file_path>_RESULT.ll
        with open(f"{file_path}_RESULT.ll", 'w+') as f2:
            f2.write("\n".join(visitor_llvm.LLVM))
        f2.close()

        visitor_mips = MIPSVisitor()
        visitor_mips.visit(AST)

        # Write generated MIPS to <file_path>_RESULT.asm
        with open(f"{file_path}_RESULT.asm", 'w+') as f2:
            f2.write("\n".join(visitor_mips.MIPS))
        f2.close()

        # Clear the terminal
        os.system("clear")
        print("GENERATED:")
        if id == "1" or id == "2":
            # Run generated LLVM and print output to terminal and to <file_path>_RESULT.txt
            os.system(f"lli {file_path}_RESULT.ll | tee {file_path}_RESULT.txt")
            f1 = open(f"{file_path}_RESULT.txt", 'r')
        elif id == "3" or id == "4":
            os.system(f"java -jar Mars4_5.jar sm {file_path}_RESULT.asm | tee {file_path}_RESULT.txt")
            output = "".join(open(f"{file_path}_RESULT.txt", 'r').readlines()[2:])
            f1 = open(f"{file_path}_RESULT.txt", 'r')
        # Run LLVM generated by terminal and print output to terminal and to <file_path>_CMP.txt
        print("\n\nEXPECTED:")
        os.system(f"clang -Wno-everything -emit-llvm -S {file_path}.c -o {file_path}.ll")
        os.system(f"lli {file_path}.ll | tee {file_path}_CMP.txt")
        f2 = open(f"{file_path}_CMP.txt", 'r')

        print("\n")

        if id == "1" or id == "2":
            # If the outputs are equal, write to output file that the test succeeded
            if f1.read() == f2.read():
                s = f"{filename} succeeded\n"
                print(s)
                OUTPUT.write(s)
            # If they aren't, write to output file that the test failed
            else:
                s = f"{filename} failed\n"
                print(s)
                OUTPUT.write(s)
        else:
            print("\n(s)ucceeded or (f)ailed?")
            validInput = False
            while (not validInput):
                inp = input().lower()
                if inp == "s":
                    validInput = True
                    s = f"{filename} succeeded\n"
                    print(s)
                    OUTPUT.write(s)
                elif inp == "f":
                    validInput = True
                    s = f"{filename} failed\n"
                    print(s)
                    OUTPUT.write(s)

        f2.close()

    # If an exception was caught, write to output file that the test crashed and print out error msg
    except Exception as e:
        s = f"{filename} crashed\n"
        print(s)
        print(str(e))
        OUTPUT.write(s)
    
    f1.close()
